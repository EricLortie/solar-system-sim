<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --panel-bg: rgba(10, 15, 30, 0.95);
            --panel-border: rgba(100, 150, 255, 0.3);
            --text-primary: #e0e8ff;
            --text-secondary: #8090b0;
            --accent: #4a90d9;
            --accent-hover: #6ab0f9;
            --button-bg: rgba(74, 144, 217, 0.3);
            --toggle-active: #4a90d9;
            --toggle-inactive: #2a3a5a;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000010;
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .panel {
            position: fixed;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .panel h2 {
            font-size: 14px;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel h3 {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin: 10px 0 6px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #controls {
            top: 20px;
            left: 20px;
            width: 260px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        #controls::-webkit-scrollbar {
            width: 6px;
        }

        #controls::-webkit-scrollbar-track {
            background: transparent;
        }

        #controls::-webkit-scrollbar-thumb {
            background: var(--panel-border);
            border-radius: 3px;
        }

        #view-controls {
            top: 20px;
            left: 300px;
            width: 220px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        #view-controls::-webkit-scrollbar {
            width: 6px;
        }

        #view-controls::-webkit-scrollbar-track {
            background: transparent;
        }

        #view-controls::-webkit-scrollbar-thumb {
            background: var(--panel-border);
            border-radius: 3px;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 8px 0;
        }

        .preset-btn {
            background: rgba(40, 50, 80, 0.5);
            border: 1px solid var(--panel-border);
            color: var(--text-primary);
            padding: 8px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-btn:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: var(--accent);
        }

        .preset-btn.active {
            background: rgba(74, 144, 217, 0.5);
            border-color: var(--accent);
        }

        .cinematic-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(255, 100, 100, 0.2);
            border: 1px solid rgba(255, 100, 100, 0.4);
            border-radius: 6px;
            margin-top: 8px;
            font-size: 12px;
        }

        .cinematic-indicator.active {
            background: rgba(100, 255, 100, 0.2);
            border-color: rgba(100, 255, 100, 0.4);
        }

        .cinematic-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6666;
            animation: blink 1s infinite;
        }

        .cinematic-indicator.active .cinematic-dot {
            background: #66ff66;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #info-panel {
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }

        #info-panel::-webkit-scrollbar {
            width: 6px;
        }

        #info-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        #info-panel::-webkit-scrollbar-thumb {
            background: var(--panel-border);
            border-radius: 3px;
        }

        .btn {
            background: var(--button-bg);
            border: 1px solid var(--accent);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: rgba(74, 144, 217, 0.5);
            border-color: var(--accent-hover);
        }

        .btn-secondary {
            background: rgba(40, 50, 80, 0.5);
            border-color: var(--panel-border);
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        .toggle-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 12px 0;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: var(--toggle-inactive);
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: var(--toggle-active);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .slider-group {
            margin: 12px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--toggle-inactive);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(100, 150, 255, 0.1);
            font-size: 13px;
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .info-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .star-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .planet-list {
            margin-top: 12px;
        }

        .planet-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: rgba(40, 50, 80, 0.3);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .planet-item:hover {
            background: rgba(74, 144, 217, 0.3);
        }

        .planet-item.selected {
            background: rgba(74, 144, 217, 0.4);
            border: 1px solid var(--accent);
        }

        .planet-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .planet-name {
            flex-grow: 1;
            font-weight: 500;
        }

        .planet-type {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .composition-bar {
            height: 8px;
            background: var(--toggle-inactive);
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
            display: flex;
        }

        .composition-segment {
            height: 100%;
            transition: width 0.3s;
        }

        .config-group {
            margin: 12px 0;
            padding: 10px;
            background: rgba(40, 50, 80, 0.2);
            border-radius: 8px;
        }

        .config-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 8px 0;
        }

        .config-input {
            width: 60px;
            padding: 4px 8px;
            background: var(--toggle-inactive);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            text-align: center;
        }

        .config-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .seed-input {
            width: 100%;
            padding: 8px;
            background: var(--toggle-inactive);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 12px;
            margin-bottom: 8px;
        }

        .seed-input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #help-text {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--text-secondary);
            text-align: center;
            pointer-events: none;
        }

        .bottom-bar {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .time-display {
            background: var(--panel-bg);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
        }

        .scale-display {
            background: var(--panel-bg);
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--panel-border);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scale-bar {
            width: 50px;
            height: 3px;
            background: var(--accent);
            border-radius: 2px;
        }

        #mini-map {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(10, 15, 30, 0.9);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            display: none;
            overflow: hidden;
        }

        #mini-map canvas {
            width: 100%;
            height: 100%;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .toolbar-btn {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toolbar-btn:hover {
            background: rgba(74, 144, 217, 0.3);
            border-color: var(--accent);
        }

        .fullscreen-active .panel,
        .fullscreen-active .toolbar,
        .fullscreen-active #help-text,
        .fullscreen-active .bottom-bar {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .fullscreen-active:hover .panel,
        .fullscreen-active:hover .toolbar,
        .fullscreen-active:hover #help-text,
        .fullscreen-active:hover .bottom-bar {
            opacity: 1;
            pointer-events: auto;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .loading {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="mini-map-canvas" width="150" height="150"></canvas>

    <div class="toolbar">
        <button class="toolbar-btn" id="screenshot-btn" title="Take Screenshot">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
            Screenshot
        </button>
        <button class="toolbar-btn" id="fullscreen-btn" title="Toggle Fullscreen">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="15 3 21 3 21 9"></polyline>
                <polyline points="9 21 3 21 3 15"></polyline>
                <line x1="21" y1="3" x2="14" y2="10"></line>
                <line x1="3" y1="21" x2="10" y2="14"></line>
            </svg>
            Fullscreen
        </button>
    </div>

    <div id="controls" class="panel">
        <h2>Solar System Generator</h2>

        <input type="text" class="seed-input" id="seed-input" placeholder="Enter seed (optional)">
        <button id="generate-btn" class="btn">Generate New System</button>

        <div class="slider-group">
            <div class="slider-label">
                <span>Time Speed</span>
                <span id="speed-value">1.0x</span>
            </div>
            <input type="range" class="slider" id="speed-slider" min="0" max="100" value="20">
        </div>

        <h3>Display Options</h3>
        <div class="toggle-group">
            <div class="toggle-item">
                <span>Show Orbits</span>
                <div class="toggle-switch active" data-toggle="orbits"></div>
            </div>
            <div class="toggle-item">
                <span>Show Labels</span>
                <div class="toggle-switch active" data-toggle="labels"></div>
            </div>
            <div class="toggle-item">
                <span>Show Moons</span>
                <div class="toggle-switch active" data-toggle="moons"></div>
            </div>
            <div class="toggle-item">
                <span>Show Asteroids</span>
                <div class="toggle-switch active" data-toggle="asteroids"></div>
            </div>
            <div class="toggle-item">
                <span>Show Comets</span>
                <div class="toggle-switch active" data-toggle="comets"></div>
            </div>
            <div class="toggle-item">
                <span>Show Habitable Zone</span>
                <div class="toggle-switch" data-toggle="habitable"></div>
            </div>
            <div class="toggle-item">
                <span>Show Trails</span>
                <div class="toggle-switch" data-toggle="trails"></div>
            </div>
            <div class="toggle-item">
                <span>Show Mini-Map</span>
                <div class="toggle-switch" data-toggle="minimap"></div>
            </div>
        </div>

        <h3>Generation Config</h3>
        <div class="config-group">
            <div class="config-row">
                <span>Min Planets</span>
                <input type="number" class="config-input" id="min-planets" value="3" min="1" max="15">
            </div>
            <div class="config-row">
                <span>Max Planets</span>
                <input type="number" class="config-input" id="max-planets" value="12" min="1" max="20">
            </div>
            <div class="config-row">
                <span>Max Moons</span>
                <input type="number" class="config-input" id="max-moons" value="8" min="0" max="20">
            </div>
            <div class="config-row">
                <span>Binary Star %</span>
                <input type="number" class="config-input" id="binary-chance" value="20" min="0" max="100">
            </div>
        </div>

        <button id="reset-view-btn" class="btn btn-secondary">Reset View</button>
    </div>

    <div id="view-controls" class="panel">
        <h2>View Controls</h2>

        <h3>Camera Tilt</h3>
        <div class="slider-group">
            <div class="slider-label">
                <span>Vertical Tilt</span>
                <span id="tilt-value">0°</span>
            </div>
            <input type="range" class="slider" id="tilt-slider" min="-60" max="60" value="0">
        </div>

        <div class="slider-group">
            <div class="slider-label">
                <span>Rotation</span>
                <span id="rotation-value">0°</span>
            </div>
            <input type="range" class="slider" id="rotation-slider" min="-180" max="180" value="0">
        </div>

        <h3>Preset Views</h3>
        <div class="preset-grid">
            <button class="preset-btn" data-preset="system">Full System</button>
            <button class="preset-btn" data-preset="top">Top Down</button>
            <button class="preset-btn" data-preset="angled">Angled</button>
            <button class="preset-btn" data-preset="edge">Edge On</button>
            <button class="preset-btn" data-preset="inner">Inner Planets</button>
            <button class="preset-btn" data-preset="outer">Outer Planets</button>
            <button class="preset-btn" data-preset="star">Star Close-up</button>
            <button class="preset-btn" data-preset="random">Random Planet</button>
        </div>

        <h3>Cinematic Mode</h3>
        <button id="cinematic-btn" class="btn">Start Cinematic</button>
        <div class="slider-group">
            <div class="slider-label">
                <span>Scene Duration</span>
                <span id="scene-duration-value">8s</span>
            </div>
            <input type="range" class="slider" id="scene-duration-slider" min="3" max="20" value="8">
        </div>
        <div id="cinematic-status" class="cinematic-indicator">
            <div class="cinematic-dot"></div>
            <span>Cinematic Off</span>
        </div>
    </div>

    <div id="info-panel" class="panel">
        <h2>System Information</h2>
        <div id="star-info"></div>
        <div id="system-stats"></div>
        <h3>Planets</h3>
        <div id="planet-list" class="planet-list"></div>
        <div id="selected-info" style="display: none;">
            <h3 id="selected-title">Selected Object</h3>
            <div id="selected-details"></div>
        </div>
    </div>

    <div id="help-text">
        Scroll to zoom | Drag to pan | Click planet to select | Double-click to focus | C or Space for Cinematic | F for Fullscreen
    </div>

    <div class="bottom-bar">
        <div class="time-display">
            <span id="time-display">Year 0, Day 0</span>
        </div>
        <div class="scale-display">
            <div class="scale-bar"></div>
            <span id="scale-value">1 AU</span>
        </div>
        <div>Zoom: <span id="zoom-level">100%</span></div>
    </div>

    <div id="mini-map">
        <canvas id="mini-map-canvas" width="150" height="150"></canvas>
    </div>

    <script>
        // ============================================
        // SEEDED RANDOM NUMBER GENERATOR
        // ============================================
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }

            next() {
                this.seed = (this.seed * 1103515245 + 12345) & 0x7fffffff;
                return this.seed / 0x7fffffff;
            }

            random(min = 0, max = 1) {
                return min + this.next() * (max - min);
            }

            randomInt(min, max) {
                return Math.floor(this.random(min, max + 1));
            }

            randomChoice(arr) {
                return arr[Math.floor(this.next() * arr.length)];
            }
        }

        let rng = new SeededRandom(Date.now());

        function setRandomSeed(seed) {
            if (typeof seed === 'string') {
                let hash = 0;
                for (let i = 0; i < seed.length; i++) {
                    hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                    hash = hash & hash;
                }
                seed = Math.abs(hash);
            }
            rng = new SeededRandom(seed);
            return seed;
        }

        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            minPlanets: 3,
            maxPlanets: 12,
            maxMoons: 8,
            asteroidBeltChance: 0.6,
            ringChance: 0.4,
            baseOrbitRadius: 80,
            orbitSpacing: 60,
            timeScale: 1,
            trailLength: 50,
            binaryStarChance: 0.2,
            cometCount: { min: 1, max: 3 }
        };

        // ============================================
        // COMET TYPES
        // ============================================
        const COMET_TYPES = {
            waterIce: {
                name: 'Water Ice Comet',
                color: '#aaddff',
                tailColor: { r: 170, g: 220, b: 255 },
                dustColor: { r: 255, g: 220, b: 180 },
                volatility: 1.0,  // How easily it sublimates (affects tail activation distance)
                tailBrightness: 1.0
            },
            carbonDioxide: {
                name: 'CO2 Ice Comet',
                color: '#ddddff',
                tailColor: { r: 200, g: 200, b: 255 },
                dustColor: { r: 220, g: 200, b: 180 },
                volatility: 1.5,  // CO2 sublimates further from star
                tailBrightness: 0.8
            },
            methane: {
                name: 'Methane Ice Comet',
                color: '#aaffdd',
                tailColor: { r: 170, g: 255, b: 220 },
                dustColor: { r: 200, g: 220, b: 180 },
                volatility: 2.0,  // Methane is very volatile
                tailBrightness: 0.6
            },
            mixed: {
                name: 'Mixed Composition Comet',
                color: '#ccddee',
                tailColor: { r: 200, g: 220, b: 240 },
                dustColor: { r: 240, g: 220, b: 200 },
                volatility: 1.2,
                tailBrightness: 0.9
            }
        };

        // ============================================
        // ORBITAL PHYSICS
        // ============================================
        const PHYSICS = {
            // All units normalized: 1 AU = 100 units, 1 Solar Mass = 1, 1 Earth Mass = 1
            // Time unit chosen so Earth year = 365 time units

            G: 1, // Gravitational constant (normalized)
            AU: 100, // 1 AU in our distance units

            // Calculate orbital period using Kepler's 3rd law: T^2 = (4*pi^2 * a^3) / (G * M)
            // Simplified: T = sqrt(a^3 / M) * 365 (in days, for a in AU, M in solar masses)
            orbitalPeriod: function(semiMajorAxisAU, starMassSolar) {
                return Math.sqrt(Math.pow(semiMajorAxisAU, 3) / starMassSolar) * 365;
            },

            // Orbital velocity at distance r for circular orbit: v = sqrt(G*M/r)
            // Returns velocity factor (higher = faster)
            orbitalVelocity: function(distanceAU, starMassSolar) {
                return Math.sqrt(starMassSolar / distanceAU);
            },

            // Hill sphere radius: r_H = a * (m_planet / (3 * M_star))^(1/3)
            // This is the region where a planet's gravity dominates
            hillSphere: function(orbitRadiusAU, planetMassEarth, starMassSolar) {
                const planetMassSolar = planetMassEarth / 333000; // Earth masses to Solar masses
                return orbitRadiusAU * Math.pow(planetMassSolar / (3 * starMassSolar), 1/3);
            },

            // Minimum separation between planets (in mutual Hill radii)
            // Stable systems typically have 10+ mutual Hill radii separation
            minPlanetSeparation: function(orbit1AU, mass1Earth, orbit2AU, mass2Earth, starMassSolar) {
                const hill1 = this.hillSphere(orbit1AU, mass1Earth, starMassSolar);
                const hill2 = this.hillSphere(orbit2AU, mass2Earth, starMassSolar);
                const mutualHill = (hill1 + hill2) / 2;
                return mutualHill * 10; // 10 mutual Hill radii for stability
            },

            // Frost line: distance where water ice can condense
            // Approximately 2.7 AU * sqrt(L/L_sun) for water ice
            frostLine: function(luminositySolar) {
                return 2.7 * Math.sqrt(luminositySolar);
            },

            // Inner edge where planets can exist (Roche limit, tidal destruction)
            // Roughly 0.01 AU for rocky planets around Sun-like stars
            innerLimit: function(starMassSolar, starRadiusSolar) {
                return Math.max(0.02, starRadiusSolar * 0.01);
            },

            // Calculate escape velocity: v_esc = sqrt(2*G*M/r)
            escapeVelocity: function(massEarth, radiusEarth) {
                // Normalized so Earth = 1
                return Math.sqrt(massEarth / radiusEarth);
            },

            // Resonance locations relative to a planet's orbit
            // Returns array of unstable orbital radii (where asteroids get ejected)
            resonanceGaps: function(planetOrbitAU) {
                // Major mean-motion resonances that create gaps
                // Ratio is asteroid_period / planet_period
                const resonances = [
                    { ratio: 4/1, width: 0.02 },   // 4:1
                    { ratio: 3/1, width: 0.03 },   // 3:1 (strong)
                    { ratio: 5/2, width: 0.02 },   // 5:2
                    { ratio: 7/3, width: 0.015 },  // 7:3
                    { ratio: 2/1, width: 0.04 },   // 2:1 (strong)
                ];

                return resonances.map(r => ({
                    // From Kepler's 3rd: a_asteroid/a_planet = (T_asteroid/T_planet)^(2/3)
                    distance: planetOrbitAU * Math.pow(r.ratio, 2/3),
                    width: planetOrbitAU * r.width
                }));
            }
        };

        // ============================================
        // SYSTEM ARCHETYPES
        // ============================================
        const SYSTEM_ARCHETYPES = {
            solarLike: {
                name: 'Solar System Type',
                description: 'Rocky inner planets, gas giants beyond frost line',
                probability: 0.35,
                planetCount: { min: 4, max: 10 },
                features: {
                    hasHotJupiter: false,
                    innerRockyZone: true,
                    outerGiantZone: true,
                    asteroidBelt: true,
                    kuiperBelt: true
                }
            },
            hotJupiter: {
                name: 'Hot Jupiter System',
                description: 'Gas giant very close to star, few other planets',
                probability: 0.15,
                planetCount: { min: 1, max: 4 },
                features: {
                    hasHotJupiter: true,
                    innerRockyZone: false,
                    outerGiantZone: false,
                    asteroidBelt: false,
                    kuiperBelt: true
                }
            },
            superEarth: {
                name: 'Super-Earth System',
                description: 'Multiple large rocky planets, tightly packed',
                probability: 0.25,
                planetCount: { min: 3, max: 7 },
                features: {
                    hasHotJupiter: false,
                    innerRockyZone: true,
                    outerGiantZone: false,
                    asteroidBelt: false,
                    kuiperBelt: true
                }
            },
            compact: {
                name: 'Compact Multi-Planet',
                description: 'Many small planets in tight orbits (like TRAPPIST-1)',
                probability: 0.15,
                planetCount: { min: 5, max: 8 },
                features: {
                    hasHotJupiter: false,
                    innerRockyZone: true,
                    outerGiantZone: false,
                    asteroidBelt: false,
                    kuiperBelt: false
                }
            },
            sparse: {
                name: 'Sparse System',
                description: 'Few widely-spaced planets',
                probability: 0.10,
                planetCount: { min: 2, max: 4 },
                features: {
                    hasHotJupiter: false,
                    innerRockyZone: true,
                    outerGiantZone: true,
                    asteroidBelt: true,
                    kuiperBelt: true
                }
            }
        };

        // ============================================
        // STAR CLASSES
        // ============================================
        const STAR_CLASSES = {
            O: {
                name: 'O-Class (Blue Supergiant)',
                color: '#9bb0ff',
                tempMin: 30000, tempMax: 50000,
                radiusMin: 6.6, radiusMax: 15,
                massMin: 16, massMax: 150,
                luminosityMin: 30000, luminosityMax: 1000000,
                probability: 0.00003
            },
            B: {
                name: 'B-Class (Blue Giant)',
                color: '#aabfff',
                tempMin: 10000, tempMax: 30000,
                radiusMin: 1.8, radiusMax: 6.6,
                massMin: 2.1, massMax: 16,
                luminosityMin: 25, luminosityMax: 30000,
                probability: 0.13
            },
            A: {
                name: 'A-Class (White)',
                color: '#cad7ff',
                tempMin: 7500, tempMax: 10000,
                radiusMin: 1.4, radiusMax: 1.8,
                massMin: 1.4, massMax: 2.1,
                luminosityMin: 5, luminosityMax: 25,
                probability: 0.6
            },
            F: {
                name: 'F-Class (Yellow-White)',
                color: '#f8f7ff',
                tempMin: 6000, tempMax: 7500,
                radiusMin: 1.15, radiusMax: 1.4,
                massMin: 1.04, massMax: 1.4,
                luminosityMin: 1.5, luminosityMax: 5,
                probability: 3
            },
            G: {
                name: 'G-Class (Yellow - Sun-like)',
                color: '#fff4ea',
                tempMin: 5200, tempMax: 6000,
                radiusMin: 0.96, radiusMax: 1.15,
                massMin: 0.8, massMax: 1.04,
                luminosityMin: 0.6, luminosityMax: 1.5,
                probability: 7.6
            },
            K: {
                name: 'K-Class (Orange)',
                color: '#ffd2a1',
                tempMin: 3700, tempMax: 5200,
                radiusMin: 0.7, radiusMax: 0.96,
                massMin: 0.45, massMax: 0.8,
                luminosityMin: 0.08, luminosityMax: 0.6,
                probability: 12.1
            },
            M: {
                name: 'M-Class (Red Dwarf)',
                color: '#ffcc6f',
                tempMin: 2400, tempMax: 3700,
                radiusMin: 0.1, radiusMax: 0.7,
                massMin: 0.08, massMax: 0.45,
                luminosityMin: 0.0001, luminosityMax: 0.08,
                probability: 76.45
            }
        };

        // ============================================
        // PLANET TYPES
        // ============================================
        const PLANET_TYPES = {
            lavaWorld: {
                name: 'Lava World',
                colors: ['#ff4500', '#cc3300', '#ff6347', '#8b0000'],
                radiusMin: 0.4, radiusMax: 1.2,
                massMin: 0.3, massMax: 2,
                atmosphereChance: 0.2,
                atmosphereTypes: ['Sulfur Dioxide', 'Carbon Dioxide'],
                composition: { rock: 0.7, metal: 0.25, volatiles: 0.05 },
                moonChance: 0.1,
                maxMoons: 1,
                surfaceFeatures: ['lava_flows', 'volcanoes']
            },
            rocky: {
                name: 'Rocky',
                colors: ['#8b7355', '#a0522d', '#bc8f8f', '#696969'],
                radiusMin: 0.3, radiusMax: 0.8,
                massMin: 0.05, massMax: 0.5,
                atmosphereChance: 0.3,
                atmosphereTypes: ['Thin CO2', 'None', 'Trace'],
                composition: { rock: 0.65, metal: 0.3, volatiles: 0.05 },
                moonChance: 0.2,
                maxMoons: 2,
                surfaceFeatures: ['craters', 'mountains']
            },
            terrestrial: {
                name: 'Terrestrial',
                colors: ['#4a90d9', '#228b22', '#daa520', '#87ceeb'],
                radiusMin: 0.8, radiusMax: 1.5,
                massMin: 0.5, massMax: 3,
                atmosphereChance: 0.9,
                atmosphereTypes: ['Nitrogen-Oxygen', 'Nitrogen', 'CO2-Nitrogen'],
                composition: { rock: 0.45, metal: 0.25, water: 0.2, volatiles: 0.1 },
                moonChance: 0.6,
                maxMoons: 3,
                surfaceFeatures: ['continents', 'oceans', 'ice_caps', 'clouds']
            },
            oceanWorld: {
                name: 'Ocean World',
                colors: ['#1e90ff', '#4169e1', '#0077be', '#006994'],
                radiusMin: 0.9, radiusMax: 2,
                massMin: 0.8, massMax: 5,
                atmosphereChance: 0.95,
                atmosphereTypes: ['Water Vapor', 'Nitrogen-Oxygen', 'Steam'],
                composition: { water: 0.6, rock: 0.25, metal: 0.1, volatiles: 0.05 },
                moonChance: 0.5,
                maxMoons: 2,
                surfaceFeatures: ['global_ocean', 'clouds', 'storms']
            },
            iceWorld: {
                name: 'Ice World',
                colors: ['#e0ffff', '#b0e0e6', '#add8e6', '#87cefa'],
                radiusMin: 0.5, radiusMax: 1.3,
                massMin: 0.3, massMax: 2,
                atmosphereChance: 0.4,
                atmosphereTypes: ['Thin Nitrogen', 'Methane', 'None'],
                composition: { ice: 0.5, rock: 0.35, volatiles: 0.15 },
                moonChance: 0.3,
                maxMoons: 2,
                surfaceFeatures: ['ice_caps', 'cracks', 'geysers']
            },
            gasGiant: {
                name: 'Gas Giant',
                colors: ['#daa520', '#cd853f', '#d2691e', '#f4a460', '#ffdab9'],
                radiusMin: 9, radiusMax: 15,
                massMin: 50, massMax: 400,
                atmosphereChance: 1,
                atmosphereTypes: ['Hydrogen-Helium'],
                composition: { hydrogen: 0.75, helium: 0.24, other: 0.01 },
                moonChance: 0.95,
                maxMoons: 12,
                hasRings: true,
                hasBands: true,
                surfaceFeatures: ['bands', 'storms', 'great_spot']
            },
            iceGiant: {
                name: 'Ice Giant',
                colors: ['#40e0d0', '#48d1cc', '#00ced1', '#5f9ea0', '#7fffd4'],
                radiusMin: 3.5, radiusMax: 6,
                massMin: 10, massMax: 50,
                atmosphereChance: 1,
                atmosphereTypes: ['Hydrogen-Helium-Methane'],
                composition: { hydrogen: 0.15, helium: 0.15, water: 0.3, methane: 0.2, ammonia: 0.2 },
                moonChance: 0.85,
                maxMoons: 8,
                hasRings: true,
                surfaceFeatures: ['bands', 'storms']
            },
            dwarf: {
                name: 'Dwarf Planet',
                colors: ['#c0c0c0', '#a9a9a9', '#d3d3d3', '#808080'],
                radiusMin: 0.1, radiusMax: 0.4,
                massMin: 0.001, massMax: 0.05,
                atmosphereChance: 0.1,
                atmosphereTypes: ['Trace', 'None'],
                composition: { rock: 0.5, ice: 0.4, volatiles: 0.1 },
                moonChance: 0.15,
                maxMoons: 1,
                surfaceFeatures: ['craters', 'ice_patches']
            }
        };

        // ============================================
        // MOON TYPES
        // ============================================
        const MOON_TYPES = {
            rocky: { name: 'Rocky', colors: ['#808080', '#696969', '#a9a9a9'] },
            icy: { name: 'Icy', colors: ['#f0f8ff', '#e6e6fa', '#b0c4de'] },
            volcanic: { name: 'Volcanic', colors: ['#ff4500', '#ff6347', '#ffa500'] },
            captured: { name: 'Captured Asteroid', colors: ['#556b2f', '#6b8e23', '#8b4513'] }
        };

        // ============================================
        // NAME GENERATION
        // ============================================
        const NAME_PARTS = {
            prefixes: ['Kep', 'Zan', 'Vor', 'Nix', 'Tra', 'Hel', 'Cor', 'Bel', 'Aur', 'Cyr',
                       'Dra', 'Ely', 'Fal', 'Gal', 'Ion', 'Jov', 'Kry', 'Lyr', 'Mer', 'Neb',
                       'Ori', 'Pho', 'Qua', 'Rho', 'Sig', 'Tau', 'Umi', 'Veg', 'Xen', 'Zet',
                       'Alp', 'Bor', 'Cas', 'Del', 'Eps', 'Fen', 'Gam', 'Hyd', 'Iri', 'Jup'],
            middles: ['ar', 'en', 'ix', 'on', 'us', 'ia', 'or', 'an', 'el', 'is',
                      'os', 'um', 'ae', 'ius', 'eus', 'oth', 'eth', 'ath', 'yn', 'ax',
                      'ex', 'ox', 'ir', 'ur', 'al', 'ol', 'il', 'ast', 'ost', 'ist'],
            suffixes: [' Prime', ' Major', ' Minor', ' Alpha', ' Beta', '-7', '-9',
                       ' III', ' IV', ' V', ' VI', ' VII', 'a', 'is', 'us', 'ion',
                       'ius', '', '', '', '', '']
        };

        const ROMAN_NUMERALS = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X',
                                'XI', 'XII', 'XIII', 'XIV', 'XV'];

        function generateName() {
            const prefix = rng.randomChoice(NAME_PARTS.prefixes);
            const middle = rng.randomChoice(NAME_PARTS.middles);
            const suffix = rng.randomChoice(NAME_PARTS.suffixes);
            return prefix + middle + suffix;
        }

        function generateMoonName(planetName, index) {
            if (rng.next() < 0.5) {
                return planetName + ' ' + ROMAN_NUMERALS[index];
            } else {
                const suffix = rng.randomChoice(NAME_PARTS.middles);
                return planetName.split(' ')[0] + suffix;
            }
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
            if (num >= 1) return num.toFixed(2);
            if (num >= 0.01) return num.toFixed(3);
            return num.toExponential(2);
        }

        // ============================================
        // SOLAR SYSTEM GENERATION
        // ============================================
        function generateStar() {
            const classes = Object.keys(STAR_CLASSES);
            const weights = classes.map(c => STAR_CLASSES[c].probability);
            const totalWeight = weights.reduce((a, b) => a + b, 0);

            let rand = rng.next() * totalWeight;
            let selectedClass = 'G';

            for (let i = 0; i < classes.length; i++) {
                rand -= weights[i];
                if (rand <= 0) {
                    selectedClass = classes[i];
                    break;
                }
            }

            const starClass = STAR_CLASSES[selectedClass];
            const temperature = rng.random(starClass.tempMin, starClass.tempMax);
            const radius = rng.random(starClass.radiusMin, starClass.radiusMax);
            const mass = rng.random(starClass.massMin, starClass.massMax);
            const luminosity = rng.random(starClass.luminosityMin, starClass.luminosityMax);

            const hzInner = Math.sqrt(luminosity / 1.1);
            const hzOuter = Math.sqrt(luminosity / 0.53);

            // Calculate physics-based zones
            const frostLine = PHYSICS.frostLine(luminosity);
            const innerLimit = PHYSICS.innerLimit(mass, radius);

            return {
                class: selectedClass,
                name: generateName() + ' Star',
                fullName: starClass.name,
                color: starClass.color,
                temperature: Math.round(temperature),
                radius: radius,
                mass: mass,
                luminosity: luminosity,
                habitableZoneInner: hzInner,
                habitableZoneOuter: hzOuter,
                frostLine: frostLine,
                innerLimit: innerLimit,
                visualRadius: 30 + radius * 3,
                flares: [],
                nextFlare: rng.random(2000, 8000)
            };
        }

        function generateSecondStar(primaryStar) {
            // Secondary star is usually smaller
            const classes = ['K', 'M', 'G', 'F'];
            const selectedClass = rng.randomChoice(classes);
            const starClass = STAR_CLASSES[selectedClass];

            const temperature = rng.random(starClass.tempMin, starClass.tempMax);
            const radius = rng.random(starClass.radiusMin, starClass.radiusMax) * 0.8;
            const mass = rng.random(starClass.massMin, starClass.massMax) * 0.7;

            return {
                class: selectedClass,
                name: primaryStar.name.replace(' Star', ' B'),
                fullName: starClass.name,
                color: starClass.color,
                temperature: Math.round(temperature),
                radius: radius,
                mass: mass,
                visualRadius: 20 + radius * 2,
                orbitRadius: rng.random(40, 80),
                angle: rng.random(0, Math.PI * 2),
                orbitalPeriod: rng.random(50, 200)
            };
        }

        function selectSystemArchetype() {
            const archetypes = Object.keys(SYSTEM_ARCHETYPES);
            const weights = archetypes.map(a => SYSTEM_ARCHETYPES[a].probability);
            const totalWeight = weights.reduce((a, b) => a + b, 0);

            let rand = rng.next() * totalWeight;
            for (let i = 0; i < archetypes.length; i++) {
                rand -= weights[i];
                if (rand <= 0) {
                    return archetypes[i];
                }
            }
            return 'solarLike';
        }

        function getPlanetTypeForDistance(distanceAU, star, archetype) {
            const frostLine = star.frostLine;
            const hzInner = star.habitableZoneInner;
            const hzOuter = star.habitableZoneOuter;
            const arch = SYSTEM_ARCHETYPES[archetype];

            // Hot Jupiter archetype - first planet is always a gas giant
            if (arch.features.hasHotJupiter && distanceAU < 0.1) {
                return 'gasGiant';
            }

            // Super-Earth archetype - no gas giants, larger rocky/terrestrial
            if (archetype === 'superEarth') {
                if (distanceAU < hzInner * 0.5) {
                    return rng.randomChoice(['lavaWorld', 'rocky']);
                }
                return rng.randomChoice(['terrestrial', 'terrestrial', 'oceanWorld', 'rocky', 'iceWorld']);
            }

            // Compact archetype - small planets only
            if (archetype === 'compact') {
                if (distanceAU < hzInner * 0.3) {
                    return rng.randomChoice(['lavaWorld', 'rocky']);
                }
                return rng.randomChoice(['rocky', 'terrestrial', 'iceWorld', 'dwarf']);
            }

            // Physics-based type selection for other archetypes
            // Inside frost line: rocky/terrestrial planets (volatiles blown away)
            if (distanceAU < frostLine * 0.5) {
                if (distanceAU < star.innerLimit * 3) {
                    return 'lavaWorld'; // Very close to star
                }
                if (distanceAU < hzInner) {
                    return rng.randomChoice(['rocky', 'rocky', 'lavaWorld']);
                }
                if (distanceAU <= hzOuter) {
                    return rng.randomChoice(['terrestrial', 'terrestrial', 'oceanWorld', 'rocky']);
                }
                return rng.randomChoice(['rocky', 'iceWorld', 'terrestrial']);
            }

            // Near frost line: transition zone
            if (distanceAU < frostLine * 1.5) {
                return rng.randomChoice(['iceWorld', 'iceWorld', 'terrestrial', 'gasGiant']);
            }

            // Beyond frost line: gas/ice giants can form (more material available)
            if (distanceAU < frostLine * 4) {
                if (arch.features.outerGiantZone) {
                    return rng.randomChoice(['gasGiant', 'gasGiant', 'iceGiant', 'iceWorld']);
                }
                return rng.randomChoice(['iceWorld', 'iceWorld', 'dwarf']);
            }

            // Far outer system
            if (distanceAU < frostLine * 8) {
                if (arch.features.outerGiantZone) {
                    return rng.randomChoice(['iceGiant', 'iceGiant', 'gasGiant', 'iceWorld']);
                }
                return rng.randomChoice(['iceWorld', 'dwarf', 'dwarf']);
            }

            // Very far out
            return rng.randomChoice(['dwarf', 'iceWorld', 'dwarf', 'dwarf']);
        }

        function generatePlanetSurface(planet, type) {
            const features = type.surfaceFeatures || [];
            planet.surfaceDetails = {
                hasIceCaps: features.includes('ice_caps') && rng.next() > 0.3,
                hasClouds: features.includes('clouds') && rng.next() > 0.4,
                hasStorm: features.includes('storms') || features.includes('great_spot'),
                stormAngle: rng.random(0, Math.PI * 2),
                stormSize: rng.random(0.1, 0.3),
                continentSeed: rng.randomInt(0, 10000),
                bandCount: features.includes('bands') ? rng.randomInt(5, 12) : 0,
                craterCount: features.includes('craters') ? rng.randomInt(3, 8) : 0,
                craters: []
            };

            // Generate crater positions
            for (let i = 0; i < planet.surfaceDetails.craterCount; i++) {
                planet.surfaceDetails.craters.push({
                    x: rng.random(-0.8, 0.8),
                    y: rng.random(-0.8, 0.8),
                    size: rng.random(0.05, 0.15)
                });
            }
        }

        function generatePlanet(index, orbitRadiusAU, star, archetype, forceType = null) {
            const typeKey = forceType || getPlanetTypeForDistance(orbitRadiusAU, star, archetype);
            const type = PLANET_TYPES[typeKey];

            // Generate mass first (needed for physics calculations)
            const mass = rng.random(type.massMin, type.massMax);
            const radius = rng.random(type.radiusMin, type.radiusMax);

            // Physics-based orbital calculations
            const orbitalPeriod = PHYSICS.orbitalPeriod(orbitRadiusAU, star.mass);
            const orbitalVelocity = PHYSICS.orbitalVelocity(orbitRadiusAU, star.mass);
            const hillSphereAU = PHYSICS.hillSphere(orbitRadiusAU, mass, star.mass);

            // Eccentricity based on system type and position
            // Inner planets tend to be more circular, outer can be more eccentric
            let maxEccentricity = 0.1;
            if (orbitRadiusAU > star.frostLine) maxEccentricity = 0.2;
            if (orbitRadiusAU > star.frostLine * 5) maxEccentricity = 0.3;
            const eccentricity = rng.random(0, maxEccentricity);

            const planet = {
                id: index,
                name: generateName(),
                type: typeKey,
                typeName: type.name,
                color: rng.randomChoice(type.colors),
                radius: radius,
                mass: mass,
                orbitRadius: orbitRadiusAU * PHYSICS.AU, // Convert to display units
                orbitRadiusAU: orbitRadiusAU,
                eccentricity: eccentricity,
                orbitalPeriod: orbitalPeriod,
                orbitalVelocity: orbitalVelocity,
                hillSphere: hillSphereAU,
                angle: rng.random(0, Math.PI * 2),
                rotationSpeed: rng.random(0.001, 0.01),
                atmosphere: rng.next() < type.atmosphereChance ? rng.randomChoice(type.atmosphereTypes) : 'None',
                composition: { ...type.composition },
                moons: [],
                hasRings: type.hasRings && rng.next() < CONFIG.ringChance,
                hasBands: type.hasBands || false,
                ringColor: `rgba(${rng.randomInt(150, 200)}, ${rng.randomInt(150, 180)}, ${rng.randomInt(130, 160)}, 0.5)`,
                trail: [],
                selected: false
            };

            planet.visualRadius = Math.max(4, Math.min(25, 4 + Math.log(planet.radius + 1) * 8));

            // Temperature calculation using Stefan-Boltzmann approximation
            // T_planet = T_star * sqrt(R_star / (2 * distance)) * (1 - albedo)^0.25
            const albedo = typeKey === 'iceWorld' ? 0.6 : (typeKey === 'gasGiant' ? 0.5 : 0.3);
            planet.temperature = Math.round(star.temperature * Math.sqrt(star.radius / (2 * orbitRadiusAU * 215)) * Math.pow(1 - albedo, 0.25));
            planet.inHabitableZone = orbitRadiusAU >= star.habitableZoneInner && orbitRadiusAU <= star.habitableZoneOuter;
            planet.beyondFrostLine = orbitRadiusAU > star.frostLine;

            // Generate surface details
            generatePlanetSurface(planet, type);

            // Generate moons (more moons for larger planets beyond frost line)
            const moonChanceMultiplier = planet.beyondFrostLine ? 1.5 : 1.0;
            if (rng.next() < type.moonChance * moonChanceMultiplier) {
                const maxMoons = Math.min(type.maxMoons, CONFIG.maxMoons);
                const moonCount = rng.randomInt(1, maxMoons);
                for (let m = 0; m < moonCount; m++) {
                    planet.moons.push(generateMoon(planet, m, star));
                }
            }

            // Generate trojan asteroids for larger planets (physics: need significant mass)
            planet.trojans = [];
            if ((typeKey === 'gasGiant' || typeKey === 'iceGiant') && mass > 30 && rng.next() < 0.6) {
                // Trojans exist at L4 and L5 Lagrange points (60 degrees ahead/behind)
                const trojanCount = rng.randomInt(15, 40);
                for (let t = 0; t < trojanCount; t++) {
                    planet.trojans.push({
                        lagrangePoint: rng.next() < 0.5 ? 4 : 5,
                        offsetAngle: rng.random(-0.12, 0.12), // Spread around L4/L5
                        offsetRadius: rng.random(-10, 10),
                        size: rng.random(0.5, 1.5),
                        color: rng.randomChoice(['#666', '#777', '#888'])
                    });
                }
            }

            return planet;
        }

        function generateMoon(planet, index, star) {
            const moonTypeKeys = Object.keys(MOON_TYPES);
            let typeKey;

            // Moon type based on planet type and position
            if (planet.type === 'iceGiant' || planet.type === 'iceWorld') {
                typeKey = rng.next() < 0.7 ? 'icy' : rng.randomChoice(moonTypeKeys);
            } else if (planet.type === 'lavaWorld') {
                typeKey = rng.next() < 0.5 ? 'volcanic' : 'rocky';
            } else if (planet.beyondFrostLine) {
                // Beyond frost line, more icy moons
                typeKey = rng.next() < 0.5 ? 'icy' : rng.randomChoice(moonTypeKeys);
            } else {
                typeKey = rng.randomChoice(moonTypeKeys);
            }

            const type = MOON_TYPES[typeKey];

            // Moon mass in Earth masses (very small)
            const moonMass = rng.random(0.0001, 0.01); // Roughly Moon to Ganymede range

            // Moon orbit radius based on planet Hill sphere
            // Moons typically orbit within ~0.5 Hill radii
            const maxMoonOrbitAU = planet.hillSphere * 0.4;
            const minMoonOrbitAU = planet.hillSphere * 0.02;

            // Spacing based on index
            const moonOrbitAU = minMoonOrbitAU + (maxMoonOrbitAU - minMoonOrbitAU) * ((index + 1) / 8);

            // Display orbit radius (scaled for visibility)
            const baseOrbitRadius = planet.visualRadius + 15 + index * 12;

            // Orbital period around planet using simplified Kepler
            // T = 2*pi * sqrt(a^3 / (G*M_planet))
            // Normalize so inner moons orbit faster
            const planetMassSolar = planet.mass / 333000;
            const moonOrbitalPeriod = Math.sqrt(Math.pow(moonOrbitAU, 3) / planetMassSolar) * 10; // Scale factor for visibility

            return {
                id: index,
                name: generateMoonName(planet.name, index),
                type: typeKey,
                typeName: type.name,
                color: rng.randomChoice(type.colors),
                mass: moonMass,
                radius: rng.random(0.1, 0.4),
                visualRadius: rng.random(2, 5),
                orbitRadius: baseOrbitRadius,
                orbitRadiusAU: moonOrbitAU,
                orbitalPeriod: Math.max(5, moonOrbitalPeriod), // Minimum for visual stability
                angle: rng.random(0, Math.PI * 2),
                eccentricity: rng.random(0, 0.1)
            };
        }

        function generateComet(star) {
            const perihelion = rng.random(30, 100);
            const aphelion = rng.random(400, 1000);
            const semiMajorAxis = (perihelion + aphelion) / 2;
            const eccentricity = (aphelion - perihelion) / (aphelion + perihelion);

            // Select comet type
            const typeKeys = Object.keys(COMET_TYPES);
            const typeKey = rng.randomChoice(typeKeys);
            const cometType = COMET_TYPES[typeKey];

            // Calculate tail activation radius based on star luminosity and comet volatility
            // Base radius is ~3 AU for Sun-like star with water ice comet
            // Scale with sqrt of luminosity (radiation intensity falls off with square of distance)
            const baseTailRadius = 300; // 3 AU in our units (100 units = 1 AU)
            const tailActivationRadius = baseTailRadius * Math.sqrt(star.luminosity) * cometType.volatility;

            return {
                name: generateName() + ' Comet',
                type: typeKey,
                typeName: cometType.name,
                semiMajorAxis: semiMajorAxis,
                eccentricity: eccentricity,
                angle: rng.random(0, Math.PI * 2),
                orbitalPeriod: Math.pow(semiMajorAxis / 100, 1.5) * 365 * 2,
                color: cometType.color,
                tailColor: cometType.tailColor,
                dustColor: cometType.dustColor,
                tailActivationRadius: tailActivationRadius,
                maxTailLength: rng.random(40, 100),
                tailBrightness: cometType.tailBrightness,
                size: rng.random(1, 3)
            };
        }

        // Physics-based asteroid belt generation
        // Finds a gap between planets where asteroids can stably orbit
        function generateAsteroidBeltPhysics(star, planets) {
            if (planets.length < 2) return null;

            // Find the best gap for an asteroid belt (between rocky and giant planets)
            let bestGapInner = null;
            let bestGapOuter = null;
            let bestGapScore = 0;

            for (let i = 0; i < planets.length - 1; i++) {
                const innerPlanet = planets[i];
                const outerPlanet = planets[i + 1];

                const gapInnerAU = innerPlanet.orbitRadiusAU + innerPlanet.hillSphere * 3;
                const gapOuterAU = outerPlanet.orbitRadiusAU - outerPlanet.hillSphere * 3;

                // Gap must be wide enough (at least 0.5 AU equivalent space)
                const gapWidth = gapOuterAU - gapInnerAU;
                if (gapWidth < 0.3) continue;

                // Score based on: proximity to frost line, gap width, and if it's between rocky/giant
                let score = gapWidth;

                // Prefer gaps near the frost line (like our asteroid belt)
                const midGap = (gapInnerAU + gapOuterAU) / 2;
                const distToFrost = Math.abs(midGap - star.frostLine);
                score += Math.max(0, 2 - distToFrost);

                // Bonus if inner is rocky and outer is giant
                const innerIsRocky = ['rocky', 'terrestrial', 'lavaWorld', 'iceWorld', 'dwarf'].includes(innerPlanet.type);
                const outerIsGiant = ['gasGiant', 'iceGiant'].includes(outerPlanet.type);
                if (innerIsRocky && outerIsGiant) score += 2;

                if (score > bestGapScore) {
                    bestGapScore = score;
                    bestGapInner = gapInnerAU;
                    bestGapOuter = gapOuterAU;
                }
            }

            if (!bestGapInner) return null;

            // Convert to display units
            const innerRadius = bestGapInner * PHYSICS.AU;
            const outerRadius = bestGapOuter * PHYSICS.AU;

            const asteroids = [];
            const count = rng.randomInt(150, 400);

            // Get orbital resonance gaps from the outer planet (Kirkwood gaps analog)
            const outerPlanetIndex = planets.findIndex(p => p.orbitRadiusAU > bestGapOuter);
            let resonanceGaps = [];
            if (outerPlanetIndex > 0) {
                resonanceGaps = PHYSICS.resonanceGaps(planets[outerPlanetIndex].orbitRadiusAU);
            }

            for (let i = 0; i < count; i++) {
                // Distribute asteroids, avoiding resonance gaps
                let radiusAU = rng.random(bestGapInner, bestGapOuter);

                // Check if in resonance gap and nudge if so
                for (const gap of resonanceGaps) {
                    if (Math.abs(radiusAU - gap.distance) < gap.width) {
                        // Move asteroid out of the resonance gap
                        radiusAU += (rng.next() < 0.5 ? -1 : 1) * gap.width * 1.5;
                        break;
                    }
                }
                radiusAU = Math.max(bestGapInner, Math.min(bestGapOuter, radiusAU));

                // Physics-based orbital speed (Kepler)
                const orbitalPeriod = PHYSICS.orbitalPeriod(radiusAU, star.mass);

                asteroids.push({
                    angle: rng.random(0, Math.PI * 2),
                    radius: radiusAU * PHYSICS.AU,
                    radiusAU: radiusAU,
                    eccentricity: rng.random(0, 0.15),
                    size: rng.random(0.5, 2),
                    orbitalPeriod: orbitalPeriod,
                    color: rng.randomChoice(['#666', '#777', '#888', '#999', '#aaa'])
                });
            }

            return { innerRadius, outerRadius, asteroids, innerAU: bestGapInner, outerAU: bestGapOuter };
        }

        // Physics-based Kuiper belt generation
        function generateKuiperBeltPhysics(star, lastPlanetOrbitAU) {
            // Kuiper belt typically starts at 30-50 AU equivalent from star
            // Scale based on star mass and system size
            const innerAU = lastPlanetOrbitAU * 1.3 + rng.random(2, 5);
            const outerAU = innerAU + rng.random(10, 20);

            const innerRadius = innerAU * PHYSICS.AU;
            const outerRadius = outerAU * PHYSICS.AU;

            const objects = [];
            const count = rng.randomInt(200, 500);

            for (let i = 0; i < count; i++) {
                const radiusAU = rng.random(innerAU, outerAU);
                const orbitalPeriod = PHYSICS.orbitalPeriod(radiusAU, star.mass);

                objects.push({
                    angle: rng.random(0, Math.PI * 2),
                    radius: radiusAU * PHYSICS.AU,
                    radiusAU: radiusAU,
                    eccentricity: rng.random(0, 0.25), // KBOs have higher eccentricities
                    inclination: rng.random(0, 0.3), // Some vertical spread
                    size: rng.random(0.3, 1.5),
                    orbitalPeriod: orbitalPeriod,
                    color: rng.randomChoice(['#556', '#667', '#778', '#889'])
                });
            }

            return { innerRadius, outerRadius, objects, innerAU, outerAU };
        }

        // Legacy functions for backwards compatibility
        function generateAsteroidBelt(innerRadius, outerRadius) {
            const asteroids = [];
            const count = rng.randomInt(150, 400);

            for (let i = 0; i < count; i++) {
                asteroids.push({
                    angle: rng.random(0, Math.PI * 2),
                    radius: rng.random(innerRadius, outerRadius),
                    eccentricity: rng.random(0, 0.15),
                    size: rng.random(0.5, 2),
                    orbitalPeriod: 1000, // Default fallback
                    color: rng.randomChoice(['#666', '#777', '#888', '#999', '#aaa'])
                });
            }

            return { innerRadius, outerRadius, asteroids };
        }

        function generateKuiperBelt(outerPlanetOrbit) {
            const innerRadius = outerPlanetOrbit + 100;
            const outerRadius = innerRadius + 200;
            const objects = [];
            const count = rng.randomInt(200, 500);

            for (let i = 0; i < count; i++) {
                objects.push({
                    angle: rng.random(0, Math.PI * 2),
                    radius: rng.random(innerRadius, outerRadius),
                    eccentricity: rng.random(0, 0.2),
                    size: rng.random(0.3, 1.5),
                    orbitalPeriod: 5000, // Default fallback
                    color: rng.randomChoice(['#556', '#667', '#778', '#889'])
                });
            }

            return { innerRadius, outerRadius, objects };
        }

        function generateSolarSystem() {
            const star = generateStar();
            const planets = [];

            // Select system archetype based on probabilities
            const archetypeKeys = Object.keys(SYSTEM_ARCHETYPES);
            const weights = archetypeKeys.map(k => SYSTEM_ARCHETYPES[k].probability);
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let rand = rng.next() * totalWeight;
            let selectedArchetype = 'solarLike';
            for (let i = 0; i < archetypeKeys.length; i++) {
                rand -= weights[i];
                if (rand <= 0) {
                    selectedArchetype = archetypeKeys[i];
                    break;
                }
            }
            const archetype = SYSTEM_ARCHETYPES[selectedArchetype];

            // Check for binary star
            let secondaryStar = null;
            if (rng.next() < CONFIG.binaryStarChance) {
                secondaryStar = generateSecondStar(star);
            }

            // Determine planet count based on archetype
            const planetCount = rng.randomInt(archetype.planetCount.min, archetype.planetCount.max);

            // Starting orbit in AU
            let currentOrbitAU = star.innerLimit * 2;

            // If binary, start planets further out (beyond binary orbit)
            if (secondaryStar) {
                currentOrbitAU = Math.max(currentOrbitAU, secondaryStar.orbitRadius / PHYSICS.AU + 0.5);
            }

            // Hot Jupiter archetype: place gas giant very close first
            let hotJupiterIndex = -1;
            if (archetype.features.hasHotJupiter && planetCount > 0) {
                const hotJupiterOrbit = rng.random(0.03, 0.08); // Very close orbit (< 0.1 AU)
                const hotJupiter = generatePlanet(0, hotJupiterOrbit, star, selectedArchetype, 'gasGiant');
                planets.push(hotJupiter);
                hotJupiterIndex = 0;
                // Next planets start beyond the hot Jupiter's Hill sphere influence
                currentOrbitAU = hotJupiterOrbit + hotJupiter.hillSphere * 15;
            }

            // Generate remaining planets using Hill sphere spacing
            for (let i = (hotJupiterIndex >= 0 ? 1 : 0); i < planetCount; i++) {
                // Spacing based on position relative to frost line
                let spacingFactor;
                if (currentOrbitAU < star.frostLine * 0.5) {
                    // Inner system: tighter spacing (Titius-Bode-like)
                    spacingFactor = rng.random(1.4, 1.8);
                } else if (currentOrbitAU < star.frostLine * 2) {
                    // Frost line region: moderate spacing
                    spacingFactor = rng.random(1.6, 2.2);
                } else {
                    // Outer system: wider spacing
                    spacingFactor = rng.random(1.8, 2.5);
                }

                // Compact systems have tighter spacing
                if (selectedArchetype === 'compact') {
                    spacingFactor = rng.random(1.2, 1.5);
                }

                // Sparse systems have wider spacing
                if (selectedArchetype === 'sparse') {
                    spacingFactor = rng.random(2.5, 4.0);
                }

                currentOrbitAU *= spacingFactor;

                // Generate the planet
                const planet = generatePlanet(i, currentOrbitAU, star, selectedArchetype);

                // Ensure minimum separation based on Hill spheres
                if (planets.length > 0) {
                    const prevPlanet = planets[planets.length - 1];
                    const minSeparation = PHYSICS.minPlanetSeparation(
                        prevPlanet.orbitRadiusAU, prevPlanet.mass,
                        currentOrbitAU, planet.mass,
                        star.mass
                    );
                    const actualSeparation = currentOrbitAU - prevPlanet.orbitRadiusAU;

                    // If too close, push orbit outward
                    if (actualSeparation < minSeparation) {
                        currentOrbitAU = prevPlanet.orbitRadiusAU + minSeparation * 1.2;
                        planet.orbitRadiusAU = currentOrbitAU;
                        planet.orbitRadius = currentOrbitAU * PHYSICS.AU;
                        planet.orbitalPeriod = PHYSICS.orbitalPeriod(currentOrbitAU, star.mass);
                        planet.orbitalVelocity = PHYSICS.orbitalVelocity(currentOrbitAU, star.mass);
                        planet.hillSphere = PHYSICS.hillSphere(currentOrbitAU, planet.mass, star.mass);
                    }
                }

                planets.push(planet);
            }

            // Generate asteroid belt in a resonance gap (if archetype allows)
            let asteroidBelt = null;
            if (archetype.features.asteroidBelt && planets.length >= 3) {
                asteroidBelt = generateAsteroidBeltPhysics(star, planets);
            }

            // Generate Kuiper belt (if archetype allows)
            let kuiperBelt = null;
            if (archetype.features.kuiperBelt && planets.length > 0) {
                const lastPlanetOrbitAU = planets[planets.length - 1].orbitRadiusAU;
                kuiperBelt = generateKuiperBeltPhysics(star, lastPlanetOrbitAU);
            }

            // Generate comets
            const comets = [];
            const cometCount = rng.randomInt(CONFIG.cometCount.min, CONFIG.cometCount.max);
            for (let i = 0; i < cometCount; i++) {
                comets.push(generateComet(star));
            }

            return {
                star,
                secondaryStar,
                planets,
                asteroidBelt,
                kuiperBelt,
                comets,
                archetype: selectedArchetype,
                archetypeName: archetype.name
            };
        }

        // ============================================
        // CANVAS & RENDERING
        // ============================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const miniMapCanvas = document.getElementById('mini-map-canvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');

        let solarSystem = null;
        let camera = {
            x: 0,
            y: 0,
            zoom: 1,
            targetX: 0,
            targetY: 0,
            targetZoom: 1,
            following: null,
            tilt: 0,
            targetTilt: 0,
            rotation: 0,
            targetRotation: 0
        };

        let cinematic = {
            active: false,
            sceneStart: 0,
            sceneDuration: 8000,
            currentScene: null
        };

        let displayOptions = {
            orbits: true,
            labels: true,
            moons: true,
            asteroids: true,
            comets: true,
            habitable: false,
            trails: false,
            minimap: false
        };

        let selectedObject = null;
        let time = 0;
        let simulationStartTime = Date.now();
        let currentSeed = null;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function worldToScreen(x, y) {
            return {
                x: (x - camera.x) * camera.zoom + canvas.width / 2,
                y: (y - camera.y) * camera.zoom + canvas.height / 2
            };
        }

        function screenToWorld(x, y) {
            return {
                x: (x - canvas.width / 2) / camera.zoom + camera.x,
                y: (y - canvas.height / 2) / camera.zoom + camera.y
            };
        }

        function applyTransform(x, y) {
            const rotRad = camera.rotation * Math.PI / 180;
            const rotX = x * Math.cos(rotRad) - y * Math.sin(rotRad);
            const rotY = x * Math.sin(rotRad) + y * Math.cos(rotRad);
            const tiltFactor = Math.cos(camera.tilt * Math.PI / 180);
            return { x: rotX, y: rotY * tiltFactor };
        }

        function getPlanetPosition(planet, t = time) {
            const angle = planet.angle + (t * 0.005 * CONFIG.timeScale) / planet.orbitalPeriod * Math.PI * 2;
            const r = planet.orbitRadius * (1 - planet.eccentricity * Math.cos(angle));
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const transformed = applyTransform(x, y);

            return {
                x: transformed.x,
                y: transformed.y,
                angle: angle,
                worldX: x,
                worldY: y
            };
        }

        function getMoonPosition(moon, planetPos, t = time) {
            const angle = moon.angle + (t * 0.003 * CONFIG.timeScale) / moon.orbitalPeriod * Math.PI * 2;
            const r = moon.orbitRadius * (1 - moon.eccentricity * Math.cos(angle));
            const localX = Math.cos(angle) * r;
            const localY = Math.sin(angle) * r;
            const transformed = applyTransform(localX, localY);

            return {
                x: planetPos.x + transformed.x,
                y: planetPos.y + transformed.y
            };
        }

        function getCometPosition(comet, t = time) {
            const angle = comet.angle + (t * 0.002 * CONFIG.timeScale) / comet.orbitalPeriod * Math.PI * 2;
            const r = comet.semiMajorAxis * (1 - comet.eccentricity * comet.eccentricity) /
                      (1 + comet.eccentricity * Math.cos(angle));
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const transformed = applyTransform(x, y);

            return { x: transformed.x, y: transformed.y, angle: angle, r: r };
        }

        function getSecondaryStarPosition(star, t = time) {
            const angle = star.angle + (t * 0.01 * CONFIG.timeScale) / star.orbitalPeriod * Math.PI * 2;
            const x = Math.cos(angle) * star.orbitRadius;
            const y = Math.sin(angle) * star.orbitRadius;
            const transformed = applyTransform(x, y);
            return { x: transformed.x, y: transformed.y };
        }

        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        function drawStar(star, pos = null) {
            if (!pos) pos = worldToScreen(0, 0);
            const visualRadius = star.visualRadius * camera.zoom;

            // Update and draw flares
            if (star.flares) {
                star.nextFlare -= 16.67;
                if (star.nextFlare <= 0) {
                    star.flares.push({
                        angle: Math.random() * Math.PI * 2,
                        size: Math.random() * 0.5 + 0.3,
                        life: 1
                    });
                    star.nextFlare = 2000 + Math.random() * 6000;
                }

                star.flares = star.flares.filter(flare => {
                    flare.life -= 0.02;
                    if (flare.life > 0) {
                        const flareX = pos.x + Math.cos(flare.angle) * visualRadius * (1 + flare.size * flare.life);
                        const flareY = pos.y + Math.sin(flare.angle) * visualRadius * (1 + flare.size * flare.life);
                        const flareGradient = ctx.createRadialGradient(flareX, flareY, 0, flareX, flareY, visualRadius * flare.size * flare.life);
                        flareGradient.addColorStop(0, star.color);
                        flareGradient.addColorStop(1, 'transparent');
                        ctx.beginPath();
                        ctx.arc(flareX, flareY, visualRadius * flare.size * flare.life, 0, Math.PI * 2);
                        ctx.fillStyle = flareGradient;
                        ctx.fill();
                        return true;
                    }
                    return false;
                });
            }

            // Glow effect
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, visualRadius * 3);
            gradient.addColorStop(0, star.color);
            gradient.addColorStop(0.3, star.color + 'aa');
            gradient.addColorStop(0.6, star.color + '44');
            gradient.addColorStop(1, 'transparent');

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, visualRadius * 3, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Core
            const coreGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, visualRadius);
            coreGradient.addColorStop(0, '#ffffff');
            coreGradient.addColorStop(0.5, star.color);
            coreGradient.addColorStop(1, star.color + 'cc');

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, visualRadius, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
        }

        function drawSecondaryStar(star) {
            const starPos = getSecondaryStarPosition(star);
            const pos = worldToScreen(starPos.x, starPos.y);

            // Draw orbit
            if (displayOptions.orbits) {
                const centerPos = worldToScreen(0, 0);
                const rotRad = camera.rotation * Math.PI / 180;
                const tiltFactor = Math.cos(camera.tilt * Math.PI / 180);

                ctx.save();
                ctx.translate(centerPos.x, centerPos.y);
                ctx.rotate(rotRad);
                ctx.scale(1, tiltFactor);

                ctx.beginPath();
                ctx.arc(0, 0, star.orbitRadius * camera.zoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }

            drawStar(star, pos);
        }

        function drawHabitableZone(star) {
            if (!displayOptions.habitable) return;

            const inner = star.habitableZoneInner * 100 * camera.zoom;
            const outer = star.habitableZoneOuter * 100 * camera.zoom;
            const pos = worldToScreen(0, 0);

            const rotRad = camera.rotation * Math.PI / 180;
            const tiltFactor = Math.cos(camera.tilt * Math.PI / 180);

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rotRad);
            ctx.scale(1, tiltFactor);

            ctx.beginPath();
            ctx.arc(0, 0, outer, 0, Math.PI * 2);
            ctx.arc(0, 0, inner, 0, Math.PI * 2, true);
            ctx.fillStyle = 'rgba(0, 255, 100, 0.08)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(0, 255, 100, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();

            ctx.restore();
        }

        function drawOrbit(planet) {
            if (!displayOptions.orbits) return;

            const pos = worldToScreen(0, 0);
            const a = planet.orbitRadius * camera.zoom;
            const b = a * Math.sqrt(1 - planet.eccentricity * planet.eccentricity);

            const rotRad = camera.rotation * Math.PI / 180;
            const tiltFactor = Math.cos(camera.tilt * Math.PI / 180);

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rotRad);
            ctx.scale(1, tiltFactor);

            ctx.beginPath();
            ctx.ellipse(0, 0, a, b, 0, 0, Math.PI * 2);
            ctx.strokeStyle = planet.selected ? 'rgba(255, 255, 255, 0.5)' : 'rgba(100, 150, 255, 0.2)';
            ctx.lineWidth = planet.selected ? 2 : 1;
            ctx.stroke();

            ctx.restore();
        }

        function drawPlanetSurface(planet, pos, visualRadius) {
            const details = planet.surfaceDetails;
            if (!details) return;

            ctx.save();
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, visualRadius, 0, Math.PI * 2);
            ctx.clip();

            // Day/night shading - shadow on the side away from star
            const starScreenPos = worldToScreen(0, 0);
            const angleToStar = Math.atan2(starScreenPos.y - pos.y, starScreenPos.x - pos.x);

            // Bands for gas giants
            if (details.bandCount > 0) {
                for (let i = 0; i < details.bandCount; i++) {
                    const y = pos.y - visualRadius + (i / details.bandCount) * visualRadius * 2;
                    const height = visualRadius * 2 / details.bandCount;
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.15)';
                    ctx.fillRect(pos.x - visualRadius, y, visualRadius * 2, height);
                }
            }

            // Great storm spot
            if (details.hasStorm && visualRadius > 8) {
                const stormX = pos.x + Math.cos(details.stormAngle) * visualRadius * 0.4;
                const stormY = pos.y + Math.sin(details.stormAngle) * visualRadius * 0.2;
                const stormGradient = ctx.createRadialGradient(stormX, stormY, 0, stormX, stormY, visualRadius * details.stormSize);
                stormGradient.addColorStop(0, 'rgba(255, 100, 100, 0.6)');
                stormGradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.ellipse(stormX, stormY, visualRadius * details.stormSize, visualRadius * details.stormSize * 0.6, 0, 0, Math.PI * 2);
                ctx.fillStyle = stormGradient;
                ctx.fill();
            }

            // Ice caps
            if (details.hasIceCaps && visualRadius > 5) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y - visualRadius * 0.85, visualRadius * 0.4, visualRadius * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(pos.x, pos.y + visualRadius * 0.85, visualRadius * 0.35, visualRadius * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Craters
            if (details.craters && visualRadius > 6) {
                details.craters.forEach(crater => {
                    const craterX = pos.x + crater.x * visualRadius;
                    const craterY = pos.y + crater.y * visualRadius;
                    const craterSize = crater.size * visualRadius;
                    ctx.beginPath();
                    ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(craterX - craterSize * 0.2, craterY - craterSize * 0.2, craterSize * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    ctx.fill();
                });
            }

            // Clouds
            if (details.hasClouds && visualRadius > 6) {
                for (let i = 0; i < 5; i++) {
                    const cloudX = pos.x + (Math.sin(time * 0.0001 + i * 1.5) * 0.6) * visualRadius;
                    const cloudY = pos.y + (Math.cos(i * 2.1) * 0.5) * visualRadius;
                    ctx.beginPath();
                    ctx.ellipse(cloudX, cloudY, visualRadius * 0.3, visualRadius * 0.1, i * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fill();
                }
            }

            // Day/night terminator
            const shadowGradient = ctx.createLinearGradient(
                pos.x + Math.cos(angleToStar) * visualRadius,
                pos.y + Math.sin(angleToStar) * visualRadius,
                pos.x - Math.cos(angleToStar) * visualRadius,
                pos.y - Math.sin(angleToStar) * visualRadius
            );
            shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            shadowGradient.addColorStop(0.5, 'rgba(0, 0, 0, 0.1)');
            shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.6)');

            ctx.fillStyle = shadowGradient;
            ctx.fillRect(pos.x - visualRadius, pos.y - visualRadius, visualRadius * 2, visualRadius * 2);

            ctx.restore();
        }

        function drawRings(planet, pos, visualRadius) {
            if (!planet.hasRings) return;

            const ringInner = visualRadius * 1.4;
            const ringOuter = visualRadius * 2.2;

            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.scale(1, 0.3);

            ctx.beginPath();
            ctx.arc(0, 0, ringOuter, 0, Math.PI * 2);
            ctx.arc(0, 0, ringInner, 0, Math.PI * 2, true);
            ctx.fillStyle = planet.ringColor;
            ctx.fill();

            for (let i = 0; i < 3; i++) {
                const r = ringInner + (ringOuter - ringInner) * (i / 3);
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawPlanet(planet) {
            const planetPos = getPlanetPosition(planet);

            if (displayOptions.trails) {
                planet.trail.push({ x: planetPos.x, y: planetPos.y });
                if (planet.trail.length > CONFIG.trailLength) {
                    planet.trail.shift();
                }
            }

            drawOrbit(planet);

            // Draw trail
            if (displayOptions.trails && planet.trail.length >= 2) {
                ctx.beginPath();
                for (let i = 0; i < planet.trail.length; i++) {
                    const point = planet.trail[i];
                    const screenPos = worldToScreen(point.x, point.y);
                    if (i === 0) ctx.moveTo(screenPos.x, screenPos.y);
                    else ctx.lineTo(screenPos.x, screenPos.y);
                }
                ctx.strokeStyle = planet.color + '44';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            const pos = worldToScreen(planetPos.x, planetPos.y);
            const visualRadius = planet.visualRadius * camera.zoom;

            // Draw trojan asteroids
            if (displayOptions.asteroids && planet.trojans) {
                planet.trojans.forEach(trojan => {
                    const lagrangeAngle = planetPos.angle + (trojan.lagrangePoint === 4 ? Math.PI / 3 : -Math.PI / 3);
                    const tAngle = lagrangeAngle + trojan.offsetAngle;
                    const tRadius = planet.orbitRadius + trojan.offsetRadius;
                    const tx = Math.cos(tAngle) * tRadius;
                    const ty = Math.sin(tAngle) * tRadius;
                    const transformed = applyTransform(tx, ty);
                    const tPos = worldToScreen(transformed.x, transformed.y);

                    ctx.beginPath();
                    ctx.arc(tPos.x, tPos.y, Math.max(0.5, trojan.size * camera.zoom), 0, Math.PI * 2);
                    ctx.fillStyle = trojan.color;
                    ctx.fill();
                });
            }

            // Rings behind planet
            if (planet.hasRings) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, pos.y);
                ctx.clip();
                drawRings(planet, pos, visualRadius);
                ctx.restore();
            }

            // Planet body
            const gradient = ctx.createRadialGradient(
                pos.x - visualRadius * 0.3, pos.y - visualRadius * 0.3, 0,
                pos.x, pos.y, visualRadius
            );
            gradient.addColorStop(0, lightenColor(planet.color, 30));
            gradient.addColorStop(0.7, planet.color);
            gradient.addColorStop(1, darkenColor(planet.color, 30));

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, visualRadius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Surface details
            drawPlanetSurface(planet, pos, visualRadius);

            // Selection indicator
            if (planet.selected) {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, visualRadius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Habitable zone indicator
            if (planet.inHabitableZone) {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, visualRadius + 8, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(0, 255, 100, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Rings in front
            if (planet.hasRings) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, pos.y, canvas.width, canvas.height);
                ctx.clip();
                drawRings(planet, pos, visualRadius);
                ctx.restore();
            }

            // Label
            if (displayOptions.labels && camera.zoom > 0.3) {
                ctx.fillStyle = '#ffffff';
                ctx.font = `${Math.max(10, 12 * camera.zoom)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.fillText(planet.name, pos.x, pos.y + visualRadius + 15);
            }

            // Draw moons only when planet is selected and zoomed in
            if (displayOptions.moons && planet.selected && camera.zoom >= 1.2) {
                planet.moons.forEach(moon => drawMoon(moon, planetPos));
            }
        }

        function drawMoon(moon, planetPos) {
            const moonPos = getMoonPosition(moon, planetPos);
            const pos = worldToScreen(moonPos.x, moonPos.y);
            const visualRadius = moon.visualRadius * camera.zoom;

            if (visualRadius < 1) return;

            if (displayOptions.orbits && camera.zoom > 0.8) {
                const planetScreenPos = worldToScreen(planetPos.x, planetPos.y);
                ctx.beginPath();
                ctx.arc(planetScreenPos.x, planetScreenPos.y, moon.orbitRadius * camera.zoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(150, 150, 200, 0.2)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, visualRadius, 0, Math.PI * 2);
            ctx.fillStyle = moon.color;
            ctx.fill();

            if (displayOptions.labels && camera.zoom > 1.5) {
                ctx.fillStyle = '#aaaaaa';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(moon.name, pos.x, pos.y + visualRadius + 8);
            }
        }

        function drawComet(comet) {
            if (!displayOptions.comets) return;

            const cometPos = getCometPosition(comet);
            const pos = worldToScreen(cometPos.x, cometPos.y);

            // Only draw if reasonably close (visible)
            if (cometPos.r > 1000) return;

            // Calculate tail direction (away from star)
            const tailAngle = Math.atan2(cometPos.y, cometPos.x);

            // Check if within tail activation radius
            const distanceFromStar = cometPos.r;
            const withinTailRadius = distanceFromStar < comet.tailActivationRadius;

            // Calculate tail intensity based on distance (stronger when closer)
            // Tail is most intense at perihelion, fades as it moves away
            let tailIntensity = 0;
            if (withinTailRadius) {
                // Intensity scales inversely with distance squared (like radiation)
                // Normalized so max intensity is 1 at very close approach
                tailIntensity = Math.pow(1 - (distanceFromStar / comet.tailActivationRadius), 2);
                tailIntensity = Math.min(1, tailIntensity * 2); // Boost for visibility
            }

            // Only draw tail if there's enough intensity
            if (tailIntensity > 0.05) {
                const tailLength = comet.maxTailLength * camera.zoom * tailIntensity;
                const tc = comet.tailColor;
                const dc = comet.dustColor;
                const brightness = comet.tailBrightness * tailIntensity;

                // Ion tail (straight, points directly away from star)
                const tailGradient = ctx.createLinearGradient(
                    pos.x, pos.y,
                    pos.x + Math.cos(tailAngle) * tailLength,
                    pos.y + Math.sin(tailAngle) * tailLength
                );
                tailGradient.addColorStop(0, `rgba(${tc.r}, ${tc.g}, ${tc.b}, ${0.8 * brightness})`);
                tailGradient.addColorStop(0.3, `rgba(${tc.r}, ${tc.g}, ${tc.b}, ${0.4 * brightness})`);
                tailGradient.addColorStop(1, `rgba(${tc.r}, ${tc.g}, ${tc.b}, 0)`);

                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x + Math.cos(tailAngle - 0.08) * tailLength, pos.y + Math.sin(tailAngle - 0.08) * tailLength);
                ctx.lineTo(pos.x + Math.cos(tailAngle + 0.08) * tailLength, pos.y + Math.sin(tailAngle + 0.08) * tailLength);
                ctx.closePath();
                ctx.fillStyle = tailGradient;
                ctx.fill();

                // Dust tail (curved, slightly different angle due to orbital motion)
                const dustTailLength = tailLength * 0.7;
                const dustGradient = ctx.createLinearGradient(
                    pos.x, pos.y,
                    pos.x + Math.cos(tailAngle + 0.2) * dustTailLength,
                    pos.y + Math.sin(tailAngle + 0.2) * dustTailLength
                );
                dustGradient.addColorStop(0, `rgba(${dc.r}, ${dc.g}, ${dc.b}, ${0.5 * brightness})`);
                dustGradient.addColorStop(1, `rgba(${dc.r}, ${dc.g}, ${dc.b}, 0)`);

                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x + Math.cos(tailAngle + 0.12) * dustTailLength, pos.y + Math.sin(tailAngle + 0.12) * dustTailLength);
                ctx.lineTo(pos.x + Math.cos(tailAngle + 0.28) * dustTailLength, pos.y + Math.sin(tailAngle + 0.28) * dustTailLength);
                ctx.closePath();
                ctx.fillStyle = dustGradient;
                ctx.fill();
            }

            // Comet nucleus (always visible) with coma that grows when active
            const comaSize = withinTailRadius ?
                comet.size * camera.zoom * (2 + tailIntensity * 3) :
                comet.size * camera.zoom * 1.5;

            const nucleusGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, comaSize);
            nucleusGradient.addColorStop(0, '#ffffff');
            nucleusGradient.addColorStop(0.3, comet.color);
            nucleusGradient.addColorStop(1, 'transparent');

            ctx.beginPath();
            ctx.arc(pos.x, pos.y, comaSize, 0, Math.PI * 2);
            ctx.fillStyle = nucleusGradient;
            ctx.fill();
        }

        function drawAsteroidBelt(belt) {
            if (!displayOptions.asteroids || !belt) return;

            belt.asteroids.forEach(asteroid => {
                // Use Kepler-based orbital motion (same formula as planets)
                const angularSpeed = (0.005 * CONFIG.timeScale) / asteroid.orbitalPeriod * Math.PI * 2;
                asteroid.angle += angularSpeed;

                const r = asteroid.radius * (1 - asteroid.eccentricity * Math.cos(asteroid.angle));
                const x = Math.cos(asteroid.angle) * r;
                const y = Math.sin(asteroid.angle) * r;
                const transformed = applyTransform(x, y);
                const pos = worldToScreen(transformed.x, transformed.y);
                const size = asteroid.size * camera.zoom;

                if (size < 0.3) return;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, Math.max(0.3, size), 0, Math.PI * 2);
                ctx.fillStyle = asteroid.color;
                ctx.fill();
            });
        }

        function drawKuiperBelt(belt) {
            if (!displayOptions.asteroids || !belt) return;

            belt.objects.forEach(obj => {
                // Use Kepler-based orbital motion (same formula as planets)
                const angularSpeed = (0.005 * CONFIG.timeScale) / obj.orbitalPeriod * Math.PI * 2;
                obj.angle += angularSpeed;

                const r = obj.radius * (1 - obj.eccentricity * Math.cos(obj.angle));
                const x = Math.cos(obj.angle) * r;
                const y = Math.sin(obj.angle) * r;
                const transformed = applyTransform(x, y);
                const pos = worldToScreen(transformed.x, transformed.y);
                const size = obj.size * camera.zoom;

                if (size < 0.2) return;

                ctx.beginPath();
                ctx.arc(pos.x, pos.y, Math.max(0.2, size), 0, Math.PI * 2);
                ctx.fillStyle = obj.color;
                ctx.fill();
            });
        }

        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return `rgb(${R}, ${G}, ${B})`;
        }

        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, (num >> 16) - amt);
            const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
            const B = Math.max(0, (num & 0x0000FF) - amt);
            return `rgb(${R}, ${G}, ${B})`;
        }

        // ============================================
        // MINI-MAP
        // ============================================
        function drawMiniMap() {
            if (!displayOptions.minimap || !solarSystem) return;

            document.getElementById('mini-map').style.display = 'block';

            miniMapCtx.fillStyle = 'rgba(0, 0, 20, 0.9)';
            miniMapCtx.fillRect(0, 0, 150, 150);

            const maxOrbit = solarSystem.planets.length > 0
                ? solarSystem.planets[solarSystem.planets.length - 1].orbitRadius
                : 500;
            const scale = 65 / maxOrbit;
            const centerX = 75;
            const centerY = 75;

            // Draw star
            miniMapCtx.beginPath();
            miniMapCtx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            miniMapCtx.fillStyle = solarSystem.star.color;
            miniMapCtx.fill();

            // Draw planets
            solarSystem.planets.forEach(planet => {
                const pos = getPlanetPosition(planet);
                const x = centerX + pos.worldX * scale;
                const y = centerY + pos.worldY * scale;

                miniMapCtx.beginPath();
                miniMapCtx.arc(x, y, planet.selected ? 3 : 2, 0, Math.PI * 2);
                miniMapCtx.fillStyle = planet.selected ? '#ffffff' : planet.color;
                miniMapCtx.fill();
            });

            // Draw camera viewport
            const viewWidth = (canvas.width / camera.zoom) * scale;
            const viewHeight = (canvas.height / camera.zoom) * scale;
            const viewX = centerX + camera.x * scale - viewWidth / 2;
            const viewY = centerY + camera.y * scale - viewHeight / 2;

            miniMapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            miniMapCtx.lineWidth = 1;
            miniMapCtx.strokeRect(viewX, viewY, viewWidth, viewHeight);
        }

        // ============================================
        // BACKGROUND STARS
        // ============================================
        let backgroundStars = [];
        function generateBackgroundStars() {
            backgroundStars = [];
            for (let i = 0; i < 500; i++) {
                backgroundStars.push({
                    x: Math.random(),
                    y: Math.random(),
                    size: Math.random() * 1.5 + 0.5,
                    brightness: Math.random() * 0.7 + 0.3
                });
            }
        }

        function drawBackgroundStars() {
            backgroundStars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x * canvas.width, star.y * canvas.height, star.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                ctx.fill();
            });
        }

        // ============================================
        // MAIN DRAW LOOP
        // ============================================
        function draw() {
            ctx.fillStyle = '#000010';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBackgroundStars();

            if (!solarSystem) return;

            // Smooth camera
            camera.x = lerp(camera.x, camera.targetX, 0.1);
            camera.y = lerp(camera.y, camera.targetY, 0.1);
            camera.zoom = lerp(camera.zoom, camera.targetZoom, 0.1);
            camera.tilt = lerp(camera.tilt, camera.targetTilt, 0.05);
            camera.rotation = lerp(camera.rotation, camera.targetRotation, 0.05);

            if (camera.following) {
                const pos = getPlanetPosition(camera.following);
                camera.targetX = pos.x;
                camera.targetY = pos.y;
            }

            if (cinematic.active) {
                updateCinematic();
            }

            // Draw everything
            drawHabitableZone(solarSystem.star);
            drawKuiperBelt(solarSystem.kuiperBelt);
            drawAsteroidBelt(solarSystem.asteroidBelt);

            solarSystem.comets.forEach(comet => drawComet(comet));
            solarSystem.planets.forEach(planet => drawPlanet(planet));

            if (solarSystem.secondaryStar) {
                drawSecondaryStar(solarSystem.secondaryStar);
            }
            drawStar(solarSystem.star);

            drawMiniMap();
            updateTimeDisplay();
            updateScaleDisplay();

            time += 16.67;
        }

        // ============================================
        // TIME & SCALE DISPLAY
        // ============================================
        function updateTimeDisplay() {
            const elapsed = time * CONFIG.timeScale;
            const days = Math.floor(elapsed / 1000);
            const years = Math.floor(days / 365);
            const remainingDays = days % 365;
            document.getElementById('time-display').textContent = `Year ${years}, Day ${remainingDays}`;
        }

        function updateScaleDisplay() {
            const pixelsPerAU = 100 * camera.zoom;
            const scaleBarPixels = 50;
            const auValue = scaleBarPixels / pixelsPerAU;

            let scaleText;
            if (auValue >= 1) {
                scaleText = auValue.toFixed(1) + ' AU';
            } else {
                scaleText = (auValue * 149.6).toFixed(0) + ' M km';
            }
            document.getElementById('scale-value').textContent = scaleText;
        }

        // ============================================
        // CINEMATIC MODE
        // ============================================
        function updateCinematic() {
            const elapsed = Date.now() - cinematic.sceneStart;
            if (elapsed >= cinematic.sceneDuration) {
                nextCinematicScene();
            }
        }

        function nextCinematicScene() {
            cinematic.sceneStart = Date.now();

            const sceneTypes = ['planet_focus', 'system_overview', 'star_closeup', 'angled_view', 'sweep', 'comet_chase'];
            const sceneType = sceneTypes[Math.floor(Math.random() * sceneTypes.length)];

            switch(sceneType) {
                case 'planet_focus':
                    const planet = solarSystem.planets[Math.floor(Math.random() * solarSystem.planets.length)];
                    camera.following = planet;
                    camera.targetZoom = 1.5 + Math.random() * 1.5;
                    camera.targetTilt = -20 + Math.random() * 40;
                    camera.targetRotation = -30 + Math.random() * 60;
                    selectPlanet(planet);
                    break;

                case 'system_overview':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.4 + Math.random() * 0.4;
                    camera.targetTilt = 20 + Math.random() * 25;
                    camera.targetRotation = -45 + Math.random() * 90;
                    break;

                case 'star_closeup':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 2 + Math.random() * 2;
                    camera.targetTilt = -15 + Math.random() * 30;
                    camera.targetRotation = -20 + Math.random() * 40;
                    break;

                case 'angled_view':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.5 + Math.random() * 0.5;
                    camera.targetTilt = 40 + Math.random() * 20;
                    camera.targetRotation = -90 + Math.random() * 180;
                    break;

                case 'sweep':
                    const outerPlanet = solarSystem.planets[solarSystem.planets.length - 1];
                    camera.following = outerPlanet;
                    camera.targetZoom = 0.3 + Math.random() * 0.3;
                    camera.targetTilt = 10 + Math.random() * 20;
                    camera.targetRotation += 30 + Math.random() * 30;
                    selectPlanet(outerPlanet);
                    break;

                case 'comet_chase':
                    if (solarSystem.comets.length > 0) {
                        const comet = solarSystem.comets[Math.floor(Math.random() * solarSystem.comets.length)];
                        const cometPos = getCometPosition(comet);
                        camera.following = null;
                        camera.targetX = cometPos.x;
                        camera.targetY = cometPos.y;
                        camera.targetZoom = 1 + Math.random();
                        camera.targetTilt = Math.random() * 30;
                        camera.targetRotation = Math.random() * 60 - 30;
                    }
                    break;
            }

            cinematic.currentScene = sceneType;
        }

        function startCinematic() {
            cinematic.active = true;
            cinematic.sceneStart = Date.now();
            nextCinematicScene();
            updateCinematicStatus();
        }

        function stopCinematic() {
            cinematic.active = false;
            camera.following = null;
            updateCinematicStatus();
        }

        function updateCinematicStatus() {
            const status = document.getElementById('cinematic-status');
            const btn = document.getElementById('cinematic-btn');

            if (cinematic.active) {
                status.classList.add('active');
                status.querySelector('span').textContent = 'Cinematic Running';
                btn.textContent = 'Stop Cinematic';
            } else {
                status.classList.remove('active');
                status.querySelector('span').textContent = 'Cinematic Off';
                btn.textContent = 'Start Cinematic';
            }
        }

        function applyPreset(preset) {
            stopCinematic();

            switch(preset) {
                case 'system':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.6;
                    camera.targetTilt = 0;
                    camera.targetRotation = 0;
                    break;

                case 'top':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.5;
                    camera.targetTilt = 0;
                    camera.targetRotation = 0;
                    break;

                case 'angled':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.6;
                    camera.targetTilt = 45;
                    camera.targetRotation = 30;
                    break;

                case 'edge':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 0.5;
                    camera.targetTilt = 60;
                    camera.targetRotation = 0;
                    break;

                case 'inner':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 1.5;
                    camera.targetTilt = 20;
                    camera.targetRotation = 0;
                    break;

                case 'outer':
                    if (solarSystem.planets.length > 0) {
                        const outerPlanet = solarSystem.planets[solarSystem.planets.length - 1];
                        camera.following = outerPlanet;
                        camera.targetZoom = 0.4;
                        camera.targetTilt = 30;
                        camera.targetRotation = 0;
                        selectPlanet(outerPlanet);
                    }
                    break;

                case 'star':
                    camera.following = null;
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 3;
                    camera.targetTilt = 15;
                    camera.targetRotation = 0;
                    break;

                case 'random':
                    if (solarSystem.planets.length > 0) {
                        const randomPlanet = solarSystem.planets[Math.floor(Math.random() * solarSystem.planets.length)];
                        camera.following = randomPlanet;
                        camera.targetZoom = 2;
                        camera.targetTilt = -20 + Math.random() * 50;
                        camera.targetRotation = -30 + Math.random() * 60;
                        selectPlanet(randomPlanet);
                    }
                    break;
            }

            document.getElementById('tilt-slider').value = camera.targetTilt;
            document.getElementById('tilt-value').textContent = Math.round(camera.targetTilt) + '°';
            document.getElementById('rotation-slider').value = camera.targetRotation;
            document.getElementById('rotation-value').textContent = Math.round(camera.targetRotation) + '°';
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================
        function updateInfoPanel() {
            if (!solarSystem) return;

            const star = solarSystem.star;
            let starInfoHTML = `
                <div class="info-row">
                    <span class="info-label">Star</span>
                    <span class="info-value">
                        <span class="star-indicator" style="background: ${star.color}"></span>
                        ${star.name}
                    </span>
                </div>
                <div class="info-row">
                    <span class="info-label">Class</span>
                    <span class="info-value">${star.fullName}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Temperature</span>
                    <span class="info-value">${formatNumber(star.temperature)} K</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mass</span>
                    <span class="info-value">${formatNumber(star.mass)} M&#9737;</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Luminosity</span>
                    <span class="info-value">${formatNumber(star.luminosity)} L&#9737;</span>
                </div>
            `;

            if (solarSystem.secondaryStar) {
                starInfoHTML += `
                    <div class="info-row" style="margin-top: 8px; border-top: 1px solid rgba(100,150,255,0.2); padding-top: 8px;">
                        <span class="info-label">Binary Star</span>
                        <span class="info-value">
                            <span class="star-indicator" style="background: ${solarSystem.secondaryStar.color}"></span>
                            ${solarSystem.secondaryStar.name}
                        </span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Class</span>
                        <span class="info-value">${solarSystem.secondaryStar.fullName}</span>
                    </div>
                `;
            }

            document.getElementById('star-info').innerHTML = starInfoHTML;

            const totalMoons = solarSystem.planets.reduce((sum, p) => sum + p.moons.length, 0);
            const habitablePlanets = solarSystem.planets.filter(p => p.inHabitableZone).length;

            document.getElementById('system-stats').innerHTML = `
                <h3>System Stats</h3>
                <div class="info-row">
                    <span class="info-label">System Type</span>
                    <span class="info-value" style="font-size: 11px;">${solarSystem.archetypeName || 'Unknown'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Planets</span>
                    <span class="info-value">${solarSystem.planets.length}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Total Moons</span>
                    <span class="info-value">${totalMoons}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Comets</span>
                    <span class="info-value">${solarSystem.comets.length}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">In Habitable Zone</span>
                    <span class="info-value">${habitablePlanets}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Frost Line</span>
                    <span class="info-value">${formatNumber(star.frostLine)} AU</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Binary System</span>
                    <span class="info-value">${solarSystem.secondaryStar ? 'Yes' : 'No'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Seed</span>
                    <span class="info-value" style="font-size: 10px;">${currentSeed}</span>
                </div>
            `;

            const planetList = document.getElementById('planet-list');
            planetList.innerHTML = solarSystem.planets.map(planet => `
                <div class="planet-item ${planet.selected ? 'selected' : ''}" data-planet-id="${planet.id}">
                    <div class="planet-color" style="background: ${planet.color}"></div>
                    <div>
                        <div class="planet-name">${planet.name}</div>
                        <div class="planet-type">${planet.typeName}${planet.inHabitableZone ? ' - Habitable Zone' : ''}</div>
                    </div>
                </div>
            `).join('');

            planetList.querySelectorAll('.planet-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = parseInt(item.dataset.planetId);
                    selectPlanet(solarSystem.planets[id]);
                });
            });
        }

        function updateSelectedInfo(planet) {
            const panel = document.getElementById('selected-info');
            const title = document.getElementById('selected-title');
            const details = document.getElementById('selected-details');

            if (!planet) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            title.textContent = planet.name;

            let compositionHTML = '<div class="composition-bar">';
            const colors = {
                rock: '#8b7355', metal: '#a0a0a0', water: '#4a90d9', ice: '#b0e0e6',
                hydrogen: '#ffcc66', helium: '#ffe4b5', methane: '#48d1cc',
                ammonia: '#dda0dd', volatiles: '#98fb98', other: '#d3d3d3'
            };

            for (const [key, value] of Object.entries(planet.composition)) {
                if (value > 0) {
                    compositionHTML += `<div class="composition-segment" style="width: ${value * 100}%; background: ${colors[key] || '#666'}"></div>`;
                }
            }
            compositionHTML += '</div>';

            details.innerHTML = `
                <div class="info-row">
                    <span class="info-label">Type</span>
                    <span class="info-value">${planet.typeName}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Orbit Distance</span>
                    <span class="info-value">${formatNumber(planet.orbitRadiusAU)} AU</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Radius</span>
                    <span class="info-value">${formatNumber(planet.radius)} R&#8853;</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Mass</span>
                    <span class="info-value">${formatNumber(planet.mass)} M&#8853;</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Temperature</span>
                    <span class="info-value">${formatNumber(planet.temperature)} K</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Orbital Period</span>
                    <span class="info-value">${formatNumber(planet.orbitalPeriod)} days</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Eccentricity</span>
                    <span class="info-value">${planet.eccentricity.toFixed(3)}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Hill Sphere</span>
                    <span class="info-value">${formatNumber(planet.hillSphere)} AU</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Atmosphere</span>
                    <span class="info-value">${planet.atmosphere}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Moons</span>
                    <span class="info-value">${planet.moons.length}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Rings</span>
                    <span class="info-value">${planet.hasRings ? 'Yes' : 'No'}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Trojans</span>
                    <span class="info-value">${planet.trojans ? planet.trojans.length : 0}</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Composition</span>
                    <span class="info-value"></span>
                </div>
                ${compositionHTML}
                ${planet.moons.length > 0 ? `
                    <h3 style="margin-top: 12px">Moons</h3>
                    ${planet.moons.map(m => `
                        <div class="info-row">
                            <span class="info-label">${m.name}</span>
                            <span class="info-value">${m.typeName}</span>
                        </div>
                    `).join('')}
                ` : ''}
            `;
        }

        function selectPlanet(planet) {
            if (selectedObject) {
                selectedObject.selected = false;
            }

            if (planet) {
                planet.selected = true;
                selectedObject = planet;
                updateSelectedInfo(planet);
            } else {
                selectedObject = null;
                updateSelectedInfo(null);
            }

            updateInfoPanel();
        }

        function focusOnPlanet(planet) {
            selectPlanet(planet);
            camera.following = planet;
            camera.targetZoom = 2;
        }

        function findPlanetAtPosition(worldX, worldY) {
            if (!solarSystem) return null;

            for (const planet of solarSystem.planets) {
                const pos = getPlanetPosition(planet);
                const dx = worldX - pos.x;
                const dy = worldY - pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < planet.visualRadius + 10) {
                    return planet;
                }
            }
            return null;
        }

        // ============================================
        // SCREENSHOT
        // ============================================
        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `solar-system-${currentSeed}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ============================================
        // FULLSCREEN
        // ============================================
        let isFullscreen = false;

        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            if (isFullscreen) {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            camera.following = null;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = (e.clientX - lastMouseX) / camera.zoom;
                const dy = (e.clientY - lastMouseY) / camera.zoom;
                camera.targetX -= dx;
                camera.targetY -= dy;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });

        canvas.addEventListener('click', (e) => {
            if (isDragging) return;

            const worldPos = screenToWorld(e.clientX, e.clientY);
            const planet = findPlanetAtPosition(worldPos.x, worldPos.y);

            if (planet) {
                selectPlanet(planet);
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            const worldPos = screenToWorld(e.clientX, e.clientY);
            const planet = findPlanetAtPosition(worldPos.x, worldPos.y);

            if (planet) {
                focusOnPlanet(planet);
            } else {
                camera.following = null;
                camera.targetX = 0;
                camera.targetY = 0;
                camera.targetZoom = 1;
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            camera.targetZoom = clamp(camera.targetZoom * zoomFactor, 0.1, 10);
            document.getElementById('zoom-level').textContent = Math.round(camera.targetZoom * 100) + '%';
        });

        // Toggle switches
        document.querySelectorAll('.toggle-switch').forEach(toggle => {
            toggle.addEventListener('click', () => {
                toggle.classList.toggle('active');
                const option = toggle.dataset.toggle;
                displayOptions[option] = toggle.classList.contains('active');

                if (option === 'minimap' && !displayOptions.minimap) {
                    document.getElementById('mini-map').style.display = 'none';
                }
            });
        });

        // Speed slider
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        speedSlider.addEventListener('input', () => {
            const val = speedSlider.value;
            CONFIG.timeScale = Math.pow(10, (val - 20) / 40);
            speedValue.textContent = CONFIG.timeScale.toFixed(1) + 'x';
        });

        // Generate button
        document.getElementById('generate-btn').addEventListener('click', () => {
            CONFIG.minPlanets = parseInt(document.getElementById('min-planets').value) || 3;
            CONFIG.maxPlanets = parseInt(document.getElementById('max-planets').value) || 12;
            CONFIG.maxMoons = parseInt(document.getElementById('max-moons').value) || 8;
            CONFIG.binaryStarChance = (parseInt(document.getElementById('binary-chance').value) || 20) / 100;

            const seedInput = document.getElementById('seed-input').value.trim();
            if (seedInput) {
                currentSeed = setRandomSeed(seedInput);
            } else {
                currentSeed = setRandomSeed(Date.now());
            }

            solarSystem = generateSolarSystem();
            selectedObject = null;
            camera.targetX = 0;
            camera.targetY = 0;
            camera.targetZoom = 1;
            camera.following = null;
            time = 0;
            simulationStartTime = Date.now();
            updateInfoPanel();
            updateSelectedInfo(null);
        });

        // Reset view button
        document.getElementById('reset-view-btn').addEventListener('click', () => {
            stopCinematic();
            camera.targetX = 0;
            camera.targetY = 0;
            camera.targetZoom = 1;
            camera.targetTilt = 0;
            camera.targetRotation = 0;
            camera.following = null;

            document.getElementById('tilt-slider').value = 0;
            document.getElementById('tilt-value').textContent = '0°';
            document.getElementById('rotation-slider').value = 0;
            document.getElementById('rotation-value').textContent = '0°';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'r':
                case 'R':
                    document.getElementById('generate-btn').click();
                    break;
                case 'Escape':
                    stopCinematic();
                    camera.following = null;
                    selectPlanet(null);
                    if (isFullscreen) toggleFullscreen();
                    break;
                case 'Home':
                    camera.targetX = 0;
                    camera.targetY = 0;
                    camera.targetZoom = 1;
                    camera.targetTilt = 0;
                    camera.targetRotation = 0;
                    camera.following = null;
                    break;
                case 'o':
                case 'O':
                    document.querySelector('[data-toggle="orbits"]').click();
                    break;
                case 'l':
                case 'L':
                    document.querySelector('[data-toggle="labels"]').click();
                    break;
                case 'm':
                case 'M':
                    document.querySelector('[data-toggle="moons"]').click();
                    break;
                case 'h':
                case 'H':
                    document.querySelector('[data-toggle="habitable"]').click();
                    break;
                case '+':
                case '=':
                    camera.targetZoom = clamp(camera.targetZoom * 1.2, 0.1, 10);
                    break;
                case '-':
                case '_':
                    camera.targetZoom = clamp(camera.targetZoom * 0.8, 0.1, 10);
                    break;
                case 'c':
                case 'C':
                    if (cinematic.active) stopCinematic();
                    else startCinematic();
                    break;
                case ' ':
                    e.preventDefault();
                    if (cinematic.active) stopCinematic();
                    else startCinematic();
                    break;
                case 'f':
                case 'F':
                    toggleFullscreen();
                    break;
                case 's':
                case 'S':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        takeScreenshot();
                    }
                    break;
            }
        });

        // View control sliders
        const tiltSlider = document.getElementById('tilt-slider');
        const tiltValue = document.getElementById('tilt-value');
        tiltSlider.addEventListener('input', () => {
            camera.targetTilt = parseFloat(tiltSlider.value);
            tiltValue.textContent = Math.round(camera.targetTilt) + '°';
            stopCinematic();
        });

        const rotationSlider = document.getElementById('rotation-slider');
        const rotationValue = document.getElementById('rotation-value');
        rotationSlider.addEventListener('input', () => {
            camera.targetRotation = parseFloat(rotationSlider.value);
            rotationValue.textContent = Math.round(camera.targetRotation) + '°';
            stopCinematic();
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                applyPreset(preset);
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Cinematic mode
        document.getElementById('cinematic-btn').addEventListener('click', () => {
            if (cinematic.active) stopCinematic();
            else startCinematic();
        });

        const sceneDurationSlider = document.getElementById('scene-duration-slider');
        const sceneDurationValue = document.getElementById('scene-duration-value');
        sceneDurationSlider.addEventListener('input', () => {
            cinematic.sceneDuration = parseInt(sceneDurationSlider.value) * 1000;
            sceneDurationValue.textContent = sceneDurationSlider.value + 's';
        });

        // Screenshot button
        document.getElementById('screenshot-btn').addEventListener('click', takeScreenshot);

        // Fullscreen button
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                isFullscreen = false;
                document.body.classList.remove('fullscreen-active');
            }
        });

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            resizeCanvas();
            generateBackgroundStars();

            currentSeed = setRandomSeed(Date.now());
            solarSystem = generateSolarSystem();
            updateInfoPanel();

            function animate() {
                draw();
                requestAnimationFrame(animate);
            }
            animate();
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            generateBackgroundStars();
        });

        init();
    </script>
</body>
</html>
